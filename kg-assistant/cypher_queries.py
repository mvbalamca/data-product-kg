# Cypher Queries for SCM Knowledge Graph Exploration
from typing import List

CYPHER_EXAMPLES: List[str] = [
    "Q: How many data products exist?\nA: MATCH (dp:DataProduct)\nRETURN count(dp) AS DataProductCount",
    "Q: Get all data products with their basic information.\nA: MATCH (dp:DataProduct)\nRETURN dp.name AS Name, dp.type AS Type, dp.domain AS Domain, dp.subdomain AS Subdomain, dp.destination AS Destination, dp.schedule AS Schedule\nORDER BY dp.domain, dp.name",
    "Q: Show the complete pipeline flow with triggers\nA: MATCH (p1:Pipeline)-[r:TRIGGERS]->(p2:Pipeline)\nRETURN p1.name AS FromPipeline, p2.name AS ToPipeline, type(r) AS Relationship\nORDER BY p1.name, p2.name",
    "Q: Show which data products feed into others\nA: MATCH (dp1:DataProduct)-[r:FEEDS_INTO]->(dp2:DataProduct)\nRETURN dp1.name AS SourceDataProduct, dp2.name AS TargetDataProduct, dp1.domain AS SourceDomain, dp2.domain AS TargetDomain\nORDER BY dp1.domain, dp1.name",
    "Q: Show which pipelines produce which data products\nA: MATCH (p:Pipeline)-[r:PRODUCES]->(dp:DataProduct)\nRETURN p.name AS Pipeline, dp.name AS DataProduct, dp.type AS DataProductType, dp.domain AS Domain\nORDER BY p.name",
    "Q: Group data products by domain with counts\nA: MATCH (dp:DataProduct)\nRETURN dp.domain AS Domain, count(dp) AS DataProductCount, collect(dp.name) AS DataProducts\nORDER BY DataProductCount DESC",
    "Q: Show data products with their owners and stewards\nA: MATCH (dp:DataProduct)-[:OWNED_BY]->(owner:Owner)\nOPTIONAL MATCH (dp)-[:STEWARDED_BY]->(steward:Steward)\nRETURN dp.name AS DataProduct, owner.name AS Owner, collect(DISTINCT steward.name) AS Stewards\nORDER BY dp.name",
    "Q: Find data products that connect different domains\nA: MATCH (dp1:DataProduct)-[:FEEDS_INTO]->(dp2:DataProduct)\nWHERE dp1.domain <> dp2.domain\nRETURN dp1.name AS SourceProduct, dp1.domain AS SourceDomain, dp2.name AS TargetProduct, dp2.domain AS TargetDomain\nORDER BY dp1.domain, dp2.domain",
    "Q: Show data products with their quality metrics and usage\nA: MATCH (dp:DataProduct)\nOPTIONAL MATCH (dp)-[:HAS_QUALITY]->(quality:DataQuality)\nOPTIONAL MATCH (dp)-[:HAS_USAGE]->(usage:UsageStats)\nRETURN dp.name AS DataProduct, dp.data_classification AS Classification, quality AS QualityMetrics, usage AS UsageStats\nORDER BY dp.name",
    "Q: Show data products with their tags and classification\nA: MATCH (dp:DataProduct)\nOPTIONAL MATCH (dp)-[:HAS_TAG]->(tag:Tag)\nOPTIONAL MATCH (dp)-[:CLASSIFIED_AS]->(class:Classification)\nRETURN dp.name AS DataProduct, collect(DISTINCT tag.name) AS Tags, class.level AS ClassificationLevel\nORDER BY dp.name",
    "Q: Show data products with their associated tables\nA: MATCH (dp:DataProduct)\nOPTIONAL MATCH (dp)-[:USES_TABLE]->(table:Table)\nOPTIONAL MATCH (dp)-[:HAS_SCHEMA]->(schema:Schema)\nRETURN dp.name AS DataProduct, collect(DISTINCT table.name) AS Tables, schema AS SchemaInfo\nORDER BY dp.name",
    "Q: Find data products that are most connected (high impact)\nA: MATCH (dp:DataProduct)\nOPTIONAL MATCH (dp)-[:FEEDS_INTO]->(downstream:DataProduct)\nOPTIONAL MATCH (upstream:DataProduct)-[:FEEDS_INTO]->(dp)\nRETURN dp.name AS DataProduct, count(DISTINCT downstream) AS DownstreamDependencies, count(DISTINCT upstream) AS UpstreamDependencies, count(DISTINCT downstream) + count(DISTINCT upstream) AS TotalConnections\nORDER BY TotalConnections DESC",
    "Q: Determine the optimal pipeline execution order\nA: MATCH (p:Pipeline)\nOPTIONAL MATCH (p)-[:TRIGGERS]->(dependent:Pipeline)\nWITH p, count(dependent) AS dependencies\nRETURN p.name AS Pipeline, dependencies AS Dependencies, CASE WHEN dependencies = 0 THEN 'Can run first' ELSE 'Depends on ' + toString(dependencies) + ' other pipeline(s)' END AS ExecutionStatus\nORDER BY dependencies ASC",
    "Q: Analyze data products by their lifecycle stage\nA: MATCH (dp:DataProduct)\nRETURN CASE WHEN dp.name CONTAINS 'Raw' THEN 'Raw Data' WHEN dp.name CONTAINS 'Processed' OR dp.name CONTAINS 'Aggregated' THEN 'Processed Data' WHEN dp.name CONTAINS 'Combined' OR dp.name CONTAINS 'Summary' THEN 'Analytics' ELSE 'Other' END AS LifecycleStage, count(dp) AS Count, collect(dp.name) AS DataProducts\nORDER BY LifecycleStage"
]
